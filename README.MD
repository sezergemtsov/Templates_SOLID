# Учимся писать красивый код

## DRY

Так как повторение кода это неудобно, долго и нечитабельно, стоит избегать этого любыми доступными способами. Например выделять повторяющиеся участки в методы, меняя логику и входные данные таким образом, чтобы максимально гибко использовать это снова.
Пример в проекте - вывод списка продуктов на экран, который используется в нескольких местах для разных списков: 
[GitHub Pages](https://github.com/sezergemtsov/Templates_SOLID/blob/170efe4b55f063922a398531a1d62c26fe2be955/src/main/java/Customer.java#L197-L205).

## Magic numbers
Я лично плохо угадываю что произойдет в будущем, то же можно отнести и к диапазонам данных которые я буду использовать в программе. Поэтому лучше не рисковать и ставить зависимости так, чтобы можно было быть в них уверенным. Как например, здесь:
[GitHub Pages]().

## SOLID

Для разработки хорошей архитектуры программы недостаточно просто избегать повторений кода. Этот процесс является более комплексным и во многом зависит от поставленных задач и требований. Однако есть ряд правил, придерживаясь которых возможно избежать множества проблем при дальнейшем внесении изменений или расширении функционала. Они тезисно описаны в абривиатуре S.O.L.I.D

![alt text](https://github.com/sezergemtsov/Templates_SOLID/blob/main/src/main/resources/SOLID.png)

Начнем по порядку:

### Single responsibility:
Перегруженные структуры сложно использовать повторно если требования хотя бы немного будут отличаться. Поэтому хорошим тоном будет разделить функционал и передать его выполнение разным сущностям. В магазине нам нужен склад? Пусть отдельный класс отвечает за него. Нужен интерфейс для работы с клиентом? Не будем приделывать его к другим классам, создадим отдельный.
[GitHub Pages]().

### Open-Closed Principle
Наша программа разрастается, появляется все больше связей и ссылок. Но что если мы случайно изменим один из корневых элементов этого дерева связей? Вряд ли программа станет работать так как мы задумали. Но как избежать таких ошибок? Правильно! Бить по рукам когда мы полезем куда не нужно! Данное правило как раз поможет нам в этом. Открыто для расширения и закрыто для изменений. Выбираем правильно модификаторы доступа и инкапсулируем, как например здесь:
[GitHub Pages]().

### Liskov Substitution
Наследуем функционал правильно. Если в частном случае наследник не подходит по функционалу для выполнения роли предка, то может быть мы отнаследовались не от того класса?
Вот пример: ничто не мешает корзину использовать как частный случай хранилища:
[GitHub Pages]().

### Interface segregation
Перегружать интерфейсы плохо еще и тем что зачастую нам может понадобиться только малая часть функционала, а ошибки с неиспользуемой частью вобще перечеркнуть все планы по его использованию, тогда зачем собирать все в кучу если можно разделить на разные сущности и брать только то что нужно сейчас? Например как здесь:
[GitHub Pages]().

### Dependency inversion
Что если мы придумаем новую классную логику для одной из сущностей в которой уже есть зависимости?
Неужели придется менять логику везде где они уже использованы? Этого не придется делать если мы придердивались данного принципа и ставили зависимости от абстракций. Все что нам нужно реализовать идею в новом классе реализующим наш абстрактный класс или интерфейс.
Как например здесь: нам не нужно знать какой склад используется и как он выдает свое содержимое, это абстракция:
[GitHub Pages]().

